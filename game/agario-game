import pygame
import random
import time
import math

pygame.init()

# KONSTANSOK
# Képernyő mérete, címe
W, H = 900, 500
WIN = pygame.display.set_mode((W, H))
pygame.display.set_caption("Agar-IO")
FPS = 30

# Színek
COLORS = [(255,0,0), (255, 128, 0), (255,255,0), (128,255,0),(0,255,0),(0,255,128),(0,255,255),(0, 128, 255), (0,0,255), (0,0,255), (128,0,255),(255,0,255), (255,0,128),(128,128,128), (0,0,0)]

# Betűtípusok
NAME_FONT = pygame.font.SysFont("comicsans", 20)
TIME_FONT = pygame.font.SysFont("comicsans", 30)
SCORE_FONT = pygame.font.SysFont("comicsans", 26)
WINNER_FONT = pygame.font.SysFont("comicsans", 100)

# Sebességek és méretek
PLAYER_RADIUS = 10
START_VEL = 9
START_RADIUS = 7
BALL_RADIUS = 5         # pacák mérete
MASS_LOSS_TIME = 2000	# méretcsökkenés ms-ban
ROUND_TIME = 60 * 5     # max köridő

MASS_LOSS = pygame.USEREVENT + 1

# Dinamikus változók
balls = []


# FÜGGVÉNYEK
def convert_time(t):
	# konvertálja az időt sec-ből min-be
	if type(t) == str:
		return t

	if int(t) < 60:
		return str(t) + "s"
	else:
		minutes = str(t // 60)
		seconds = str(t % 60)

		if int(seconds) < 10:
			seconds = "0" + seconds

		return minutes + ":" + seconds


def draw_window(red, yellow, balls, game_time):
	WIN.fill((255,255,255))

	# kirajzoljuk a pacákat
	for ball in balls:
		pygame.draw.circle(WIN, ball[2], (ball[0], ball[1]), BALL_RADIUS)

	# kirajzoljuk a játékosokat
	pygame.draw.circle(WIN, COLORS[0], (red[0], red[1]), PLAYER_RADIUS + round(red[2]))
	pygame.draw.circle(WIN, COLORS[2], (yellow[0], yellow[1]), PLAYER_RADIUS + round(yellow[2]))

	# kiírjuk a nevüket
	red_text = NAME_FONT.render("Player 1", 1, (0, 0, 0))
	yellow_text = NAME_FONT.render("Player 2", 1, (0, 0, 0))
	WIN.blit(red_text, (red[0] - red_text.get_width() / 2, red[1] - red_text.get_height() / 2))
	WIN.blit(yellow_text, (yellow[0] - yellow_text.get_width() / 2, yellow[1] - yellow_text.get_height() / 2))

	# kiírjuk az időt
	#text = TIME_FONT.render("Time: " + convert_time(game_time), 1, (0, 0, 0))
	#WIN.blit(text, (10, 10))


def create_balls(red, yellow, balls, n):
	# létrehozza a pacákat
	for i in range(n):
		while True:
			stop = True
			x = random.randrange(0, W)
			y = random.randrange(0, H)
			red_dis = math.sqrt((x - red[0]) ** 2 + (y - red[1]) ** 2)
			yellow_dis = math.sqrt((x - yellow[0]) ** 2 + (y - yellow[1]) ** 2)
			if red_dis <= START_RADIUS + red[2] or yellow_dis <= START_RADIUS + yellow[2]:
					stop = False
			if stop:
				break

		balls.append((x, y, random.choice(COLORS)))


def yellow_handle_movement(keys_pressed, yellow, yellow_vel):                          # ezek helyett jön a NN outputja
	if keys_pressed[pygame.K_a]:  # LEFT
		if yellow[0] - yellow_vel - PLAYER_RADIUS - yellow[2] >= 0:
			yellow[0] = yellow[0] - yellow_vel
	if keys_pressed[pygame.K_d]:  # RIGHT
		if yellow[0] + yellow_vel + PLAYER_RADIUS + yellow[2] <= W:
			yellow[0] = yellow[0] + yellow_vel
	if keys_pressed[pygame.K_w]:  # UP
		if yellow[1] - yellow_vel - PLAYER_RADIUS - yellow[2] >= 0:
			yellow[1] = yellow[1] - yellow_vel
	if keys_pressed[pygame.K_s]:  # DOWN
		if yellow[1] + yellow_vel + PLAYER_RADIUS + yellow[2] <= H:
			yellow[1] = yellow[1] + yellow_vel


def red_handle_movement(keys_pressed, red, red_vel):                                   # ezek helyett jön a NN outputja
	if keys_pressed[pygame.K_LEFT]:  # LEFT
		if red[0] - red_vel - PLAYER_RADIUS - red[2] >= 0:
			red[0] = red[0] - red_vel
	if keys_pressed[pygame.K_RIGHT]:  # RIGHT
		if red[0] + red_vel + PLAYER_RADIUS + red[2] <= W:
			red[0] = red[0] + red_vel
	if keys_pressed[pygame.K_UP]:  # UP
		if red[1] - red_vel - PLAYER_RADIUS - red[2] >= 0:
			red[1] = red[1] - red_vel
	if keys_pressed[pygame.K_DOWN]:  # DOWN
		if red[1] + red_vel + PLAYER_RADIUS + red[2] <= H:
			red[1] = red[1] + red_vel


def ball_collision(yellow, red, balls):
	# kezeli ha egy játékos ütközik egy pacával
	for ball in balls:
		bx = ball[0]
		by = ball[1]

		red_dis = math.sqrt((red[0] - bx) ** 2 + (red[1] - by) ** 2)
		yellow_dis = math.sqrt((yellow[0] - bx) ** 2 + (yellow[1] - by) ** 2)

		if red_dis <= START_RADIUS + red[2]:
			red[2] = red[2] + 0.5
			balls.remove(ball)

		elif yellow_dis <= START_RADIUS + yellow[2]:
			yellow[2] = yellow[2] + 0.5
			balls.remove(ball)


def player_collision(yellow, red):
	# kezeli a játékosok ütközését
	dis = math.sqrt((yellow[0] - red[0]) ** 2 + (yellow[1] - red[1]) ** 2)
	if red[2] < yellow[2]:
		if dis < yellow[2] - red[2]*0.85:
			yellow[2] = math.sqrt(yellow[2] ** 2 + red[2] ** 2)  # a területtel arányosan nő, nem a sugárral
			red[2] = 0
			red_alive = False

	elif yellow[2] < red[2]:
		if dis < red[2] - yellow[2]*0.85:
			red[2] = math.sqrt(red[2] ** 2 + yellow[2] ** 2)  # a területtel arányosan nő, nem a sugárral
			yellow[2] = 0
			yellow_alive = False


def get_start_location(red):
	while True:
		stop = True
		x = random.randrange(0, W)
		y = random.randrange(0, H)
		dis = math.sqrt((x - red[0]) ** 2 + (y - red[1]) ** 2)
		if dis <= START_RADIUS + red[2]:
			stop = False
			break
		if stop:
			break
	return (x, y)

'''
def draw_winner(text):
	draw_text = WINNER_FONT.render(text, 1, (0,0,0))
	WIN.blit(draw_text, (W//2 - draw_text.get_width()/2, H//2 - draw_text.get_height()/2))
	pygame.display.update()
	pygame.time.delay(3000)
'''

def main():
	red_x = random.randrange(0,W)
	red_y = random.randrange(0,H)
	red_score = 0
	red = [red_x, red_y, red_score]
	red_alive = True

	yellow_x, yellow_y = get_start_location(red)
	yellow_score = 0
	yellow = [yellow_x, yellow_y, yellow_score]
	yellow_alive = True

	clock = pygame.time.Clock()
	run = True

	while run:
		clock.tick(FPS)
		for event in pygame.event.get():
			# X-re kattintáskor bezár
			if event.type == pygame.QUIT:
				run = False
				pygame.quit()

			if event.type == pygame.KEYDOWN:
				# Esc lenyomásakor bezár
				if event.key == pygame.K_ESCAPE:
					run = False
					pygame.quit()

		# Sebességek
		red_vel = START_VEL - round(red[2] / 14)
		if red_vel <= 1:
			red_vel = 1

		yellow_vel = START_VEL - round(yellow[2] / 14)
		if yellow_vel <= 1:
			yellow_vel = 1

		winner_text = ""

		#game_time = clock.tick(FPS)
		game_time = round(time.time())

		'''
		# ha az idő átlépi a ROUND_TIME-ot akkor a játék véget ér
		if game_time >= ROUND_TIME:
			# és írja ki, hogy ki nyert
			if red_score < yellow_score:
				winner_text = "Yellow Wins!"
			elif yellow_score < red_score:
				winner_text = "Red Wins!"
			else:
				winner_text = "Draw!"
			#draw_winner(winner_text)
			#run = False
			break

		'''

		# játékosok méretét csökkenti

		for event in pygame.event.get():
			if event.type == MASS_LOSS:
				if red_score > 8:
					red_score = math.floor(red_score * 0.95)

				if yellow_score > 8:
					yellow_score = math.floor(yellow_score * 0.95)


		# ha meghalt valamelyik játékos, véget ér a játék
		if not red_alive:
			winner_text = "Yellow Wins!"

		if not yellow_alive:
			winner_text = "Red Wins!"

		if winner_text != "":
			#draw_winner(winner_text)
			break


		# Függvényhívások
		create_balls(red, yellow, balls, random.randrange(200, 250))

		keys_pressed = pygame.key.get_pressed()
		yellow_handle_movement(keys_pressed, yellow, yellow_vel)
		red_handle_movement(keys_pressed, red, red_vel)

		ball_collision(yellow, red, balls)
		player_collision(yellow, red)

		draw_window(red, yellow, balls, game_time)
		pygame.display.update()

	main()

if __name__ == "__main__":
	main()
